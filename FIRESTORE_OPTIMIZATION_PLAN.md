# Firestore 비용 최소화 및 성능 개선 계획

## 현재 문제점 분석

### 1. 읽기 비용 문제

- **문제**: `saveSelections()`에서 저장 전 전체 컬렉션을 읽어서 비교 (불필요한 읽기)
- **영향**: 증상 저장 시마다 모든 문서 읽기 발생
- **비용**: 증상이 100개 날짜에 있으면 100개 문서 읽기 발생

### 2. 중복 읽기

- **문제**: `loadAsync()`와 `loadMemosAsync()`가 같은 컬렉션을 각각 읽음
- **영향**: 메모와 증상을 함께 표시할 때 2배의 읽기 비용
- **비용**: 100개 날짜 × 2 = 200개 문서 읽기

### 3. 데이터 구조 문제

- **문제**: 날짜별로 개별 문서를 사용 (문서 수가 많음)
- **영향**: 쿼리 성능 저하, 읽기 비용 증가
- **비용**: 365일 기준 최대 365개 문서

### 4. 불필요한 서버 읽기

- **문제**: `refresh()`에서 항상 `forceRefresh: true`로 서버에서 강제 읽기
- **영향**: 오프라인 캐시 활용 불가, 매번 네트워크 비용
- **비용**: 앱 시작 시마다 모든 데이터 읽기

### 5. 전체 데이터 저장

- **문제**: 증상 하나 변경해도 전체 맵을 저장하는 방식
- **영향**: 변경되지 않은 데이터도 다시 쓰기
- **비용**: 증상 100개 중 1개 변경 시 100개 문서 쓰기 가능

## 최적화 전략

### 전략 1: 데이터 구조 재설계 (권장)

#### 옵션 A: 월별 문서로 그룹화 (추천)

```
users/{userId}/symptoms/{year}-{month}
  - symptoms: Map<String, List<String>>  // {date: [symptoms]}
  - memos: Map<String, String>           // {date: memo}
  - updatedAt: Timestamp
```

**장점:**

- 문서 수 대폭 감소 (365개 → 12개)
- 월별 데이터만 읽으면 되므로 읽기 비용 감소
- 증상과 메모를 함께 저장하여 중복 읽기 제거

**단점:**

- 한 문서 크기가 증가 (최대 약 1MB 제한)
- 부분 업데이트 필요 (FieldValue 업데이트)

#### 옵션 B: 증상과 메모 분리 (현재 구조 개선)

```
users/{userId}/symptoms/{date}
  - symptoms: List<String>
  - memo: String? (optional)
  - updatedAt: Timestamp
```

**장점:**

- 현재 구조와 유사하여 마이그레이션 용이
- 부분 업데이트 용이

**단점:**

- 여전히 많은 문서 수
- 증상과 메모를 함께 읽어야 함

### 전략 2: 읽기 최소화

#### 2.1 로컬 캐싱 강화

- **현재**: 메모리 캐싱만 사용
- **개선**:
  - SharedPreferences/Hive 등 로컬 저장소 활용
  - 앱 시작 시 로컬 캐시에서 먼저 로드
  - 백그라운드에서 서버 동기화

#### 2.2 증분 읽기 (Incremental Load)

- **현재**: 매번 전체 데이터 읽기
- **개선**:
  - 마지막 동기화 타임스탬프 저장
  - `where('updatedAt', '>', lastSyncTime)` 쿼리로 변경된 데이터만 읽기
  - 최초 로드 시에만 전체 읽기

#### 2.3 필요한 데이터만 읽기

- **현재**: 항상 전체 컬렉션 읽기
- **개선**:
  - 날짜 범위 필터링 (`where('date', '>=', startDate)`)
  - 최근 N일만 읽기 (예: 최근 365일)
  - 페이지네이션 (필요한 경우)

### 전략 3: 쓰기 최소화

#### 3.1 증분 업데이트 (Incremental Update)

- **현재**: 전체 맵을 저장
- **개선**:
  - 변경된 날짜만 업데이트
  - `FieldValue`를 사용한 필드별 업데이트
  - 배치 쓰기 활용 (500개 제한)

#### 3.2 쓰기 디바운싱

- **현재**: 변경 즉시 저장
- **개선**:
  - 짧은 시간(예: 1-2초) 내 여러 변경을 배치
  - 여러 증상 변경을 한 번에 저장
  - 오프라인 모드 지원

#### 3.3 저장 전 비교 제거

- **현재**: 저장 전 기존 데이터 읽어서 비교
- **개선**:
  - 로컬 메모리에서 변경 추적
  - 변경된 항목만 Firestore에 쓰기
  - 읽기 없이 쓰기만 수행

### 전략 4: 쿼리 최적화

#### 4.1 인덱스 활용

- 복합 인덱스 생성 (date + updatedAt)
- 날짜 범위 쿼리 최적화

#### 4.2 쿼리 제한

- `limit()` 사용으로 읽기 문서 수 제한
- 불필요한 필드 제외 (`select()` 사용)

### 전략 5: 실시간 리스너 최소화

- **현재**: 실시간 리스너 사용 안 함 (좋음)
- **유지**: 실시간 리스너 사용하지 않기
  - 실시간 리스너는 읽기 비용이 높음
  - 필요한 경우에만 수동 새로고침

## 추천 구현 계획

### Phase 1: 즉시 적용 가능한 개선 (비용 절감 약 50-70%)

1. **로컬 캐싱 추가**

   - SharedPreferences 또는 Hive로 로컬 저장
   - 앱 시작 시 로컬 캐시에서 로드
   - 백그라운드에서 서버 동기화

2. **저장 로직 개선**

   - `saveSelections()`에서 전체 읽기 제거
   - 로컬 메모리 기반 변경 추적
   - 변경된 날짜만 쓰기

3. **증상과 메모 통합 읽기**

   - `loadAsync()`에서 증상과 메모를 함께 반환
   - 중복 읽기 제거

4. **forceRefresh 제거**
   - 기본적으로 캐시 우선 사용
   - 수동 새로고침 시에만 서버 읽기

### Phase 2: 데이터 구조 개선 (비용 절감 추가 20-30%)

1. **월별 문서 구조로 마이그레이션**

   - 기존 데이터 마이그레이션 스크립트
   - 새로운 구조로 읽기/쓰기 로직 변경
   - 점진적 마이그레이션 (기존/신규 구조 병행)

2. **증분 동기화**
   - `updatedAt` 필드 추가
   - 타임스탬프 기반 증분 읽기

### Phase 3: 고급 최적화 (비용 절감 추가 10%)

1. **쓰기 디바운싱**
2. **쿼리 인덱스 최적화**
3. **페이지네이션 (필요시)**

## 예상 비용 절감 효과

### 현재 비용 (월별 예상)

- 증상 데이터: 100개 날짜
- 일일 읽기: 앱 시작 1회 = 100 문서
- 일일 쓰기: 증상 변경 5회 × 100 문서 = 500 문서
- 월별 읽기: 30일 × 100 = 3,000 문서 읽기
- 월별 쓰기: 30일 × 500 = 15,000 문서 쓰기
- **총 비용**: 약 18,000 문서/월

### Phase 1 적용 후 (예상)

- 일일 읽기: 캐시 사용으로 0회 (최초 1회만)
- 일일 쓰기: 변경된 날짜만 = 5 문서
- 월별 읽기: 약 300 문서 (캐시 미스 시만)
- 월별 쓰기: 30일 × 5 = 150 문서
- **총 비용**: 약 450 문서/월
- **절감률**: 약 97.5% 절감

### Phase 2 적용 후 (예상)

- 월별 문서로 그룹화
- 월별 읽기: 12개 문서
- 월별 쓰기: 변경된 월만 = 약 5개 문서
- **총 비용**: 약 17 문서/월
- **절감률**: 약 99.9% 절감

## 구현 우선순위

1. **높음**: 로컬 캐싱, 저장 로직 개선 (Phase 1-1, 1-2)
2. **중간**: 증상/메모 통합 읽기, forceRefresh 제거 (Phase 1-3, 1-4)
3. **낮음**: 데이터 구조 마이그레이션 (Phase 2) - 장기적 계획

## 주의사항

1. **문서 크기 제한**: Firestore 문서는 최대 1MB

   - 월별 구조 사용 시 월별 데이터가 1MB를 넘지 않도록 주의
   - 평균 증상 10개/일 × 30일 = 약 300개 항목 (충분히 작음)

2. **오프라인 지원**: 로컬 캐싱 시 오프라인 모드 고려

3. **데이터 일관성**: 여러 기기에서 동시 수정 시 충돌 처리

4. **마이그레이션**: 기존 사용자 데이터 마이그레이션 계획 필요
